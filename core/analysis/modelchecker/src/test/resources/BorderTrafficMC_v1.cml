types

  CountryId = nat
  ActuatorId =nat
  
  Location = int

functions

   -- Function to calculate the distance required for the corridor based upon the target
   -- speed and the current national speed limit of the country.
   calcDistance: nat * nat -> nat
   calcDistance(targetSpeed, speedLimit) == ((speedLimit-targetSpeed)/40) + 1  -- simplified for MC
   
   -- Function to calculate the speed target the neighbouring TMS must acheive. THis is based 
   -- upon the starting location of the corridor, the required distance of the corridor, and the
   -- ultimate target speed
   calcNeighbourTarget : int * nat * nat * nat -> nat   
   calcNeighbourTarget(startLoc, target, distance, speedLimit)  ==
      target + (calcInterval(target, distance, speedLimit) * startLoc)


  calcInterval: nat * nat * nat -> nat
  calcInterval(target, distance, speedLimit) == ((speedLimit-target)/distance)
   pre speedLimit > target and distance > 0   
   
   
   --Determines if Neighbour is needed based upon the starting location and distance of the
   -- speed corridor
   --**IMPORTANT** current model of location means this is only valid for Country B!
   isNeighbourNeeded : int * nat -> bool
   isNeighbourNeeded (startLoc, distance) == startLoc + distance > 0
   
channels

  --environment channels--
  inIncidentOne : CountryId
  inIncidentTwo : Location
  inIncidentThree : nat
  incidentClearOne: CountryId 
  incidentClearTwo: Location

  --interface channels--
  neighbourRequestOne : CountryId
  neighbourRequestTwo :  CountryId
  neighbourRequestThree : nat
  neighbourOkOne : CountryId
  neighbourOkTwo : CountryId
  
 
  --internal corridor channels--
  determineCorrOne : int 
  determineCorrTwo : nat
  newCorr 
  createCorr
  disableCorr
 

chansets
  -- the main interface between countryTMSs
  interface = {neighbourRequestOne, neighbourRequestTwo, neighbourRequestThree, neighbourOkOne, neighbourOkTwo}
  
  -- interface of SoS and incident creator
  incident = {inIncidentOne, inIncidentTwo, inIncidentThree, incidentClearOne, incidentClearTwo}

  --internal channels--
  internal = {determineCorrOne, determineCorrTwo, newCorr, createCorr, disableCorr}


process CountryTMS = 
begin

 state
  -- identifiers for the TMS and its neighbour
  myId : CountryId := 1
  nId : CountryId :=2
  nationalSpeedLimit : nat :=100
  neighbourNeeded : bool := false
  targCorr : nat := 0
  distCorr : nat := 0
  locCorr : int := 0

 actions
   
   BEHAVIOUR = NEW_INCIDENT [] NEIGHBOUR_REQ
   	                     
   NEW_INCIDENT = inIncidentOne.myId -> inIncidentTwo?l -> inIncidentThree?t -> 
                  (distCorr := calcDistance(t, nationalSpeedLimit) ; locCorr := l; targCorr :=t; 
                   NEW_CORRIDOR)
   				 
   NEW_CORRIDOR = 
                 (newCorr -> Skip; 
                   //this is replaced by the body of the function, which is not allowed in FORMULA
     			  (neighbourNeeded := isNeighbourNeeded(locCorr, distCorr);
                   ([neighbourNeeded = true] & (dcl ntarg:nat := calcNeighbourTarget(locCorr, targCorr, distCorr, nationalSpeedLimit) @
                                              neighbourRequestOne!myId -> neighbourRequestTwo!nId -> 
                                              neighbourRequestThree!ntarg -> CLEAR_INCIDENT)
                    []
                    [neighbourNeeded = false] & CLEAR_INCIDENT)))
              
   CLEAR_INCIDENT = (incidentClearOne.myId -> incidentClearTwo.locCorr ->  CLEAR_CORRIDOR)
   			  
   CLEAR_CORRIDOR = [neighbourNeeded = true] & disableCorr -> Skip; neighbourOkOne!myId -> neighbourOkTwo!nId -> NEW_INCIDENT
                     []
                     [neighbourNeeded = false] & disableCorr -> Skip; BEHAVIOUR 
   
   NEIGHBOUR_REQ = neighbourRequestOne.nId -> neighbourRequestTwo.myId -> neighbourRequestThree?t -> newCorr -> Skip; NEIGHBOUR_CLEAR
                           
   NEIGHBOUR_CLEAR =  neighbourOkOne.nId -> neighbourOkTwo.myId -> disableCorr -> Skip; BEHAVIOUR
                     
  @ BEHAVIOUR			
end 
